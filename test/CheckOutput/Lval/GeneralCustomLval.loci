// RUN: %locic %s --interpret > %t
// RUN: FileCheck < %t %s

// CHECK: custom_lval.Create: Value = OrderedEqual
// CHECK: custom_lval.dissolve: Value = OrderedEqual
// CHECK: main: Value = OrderedEqual
// CHECK: custom_lval.address: Value = OrderedEqual
// CHECK: addressAssignFunction: Previous value = OrderedEqual
// CHECK: addressAssignFunction: New value = OrderedLess
// CHECK: custom_lval.dissolve: Value = OrderedLess
// CHECK: main: Value = OrderedLess
// CHECK: custom_lval.dissolve: Value = OrderedLess
// CHECK: assignFunction: Previous value = OrderedLess
// CHECK: custom_lval.assign: Previous value = OrderedLess
// CHECK: custom_lval.assign: New value = OrderedMore
// CHECK: custom_lval.dissolve: Value = OrderedMore
// CHECK: assignFunction: New value = OrderedMore
// CHECK: custom_lval.dissolve: Value = OrderedMore
// CHECK: main: Value = OrderedMore
// CHECK: custom_lval.dissolve: Value = OrderedMore
// CHECK: moveFunction: Previous value = OrderedMore
// CHECK: custom_lval.move: Value = OrderedMore
// CHECK: moveFunction: Moved value = OrderedMore
// CHECK: custom_lval.assign: Previous value = [NONE]
// CHECK: custom_lval.assign: New value = Both Zero
// CHECK: custom_lval.dissolve: Value = Both Zero
// CHECK: moveFunction: New value = Both Zero
// CHECK: custom_lval.dissolve: Value = Both Zero
// CHECK: main: Value = Both Zero

import void printf(const ubyte * str, ...);

interface serializable {
	const ubyte * toCString();
}

template <typename T>
require(T : serializable and movable<T>)
// Use a 'value_lval' since it supports move operations.
class custom_lval(bool hasValue, lval<T> value_lval_t<T> value) {
	static Create(T value) {
		printf(C"custom_lval.Create: Value = %s\n", value.toCString());
		return @(true, lval<T>(value_lval_t<T>(move value)));
	}
	
	T* address() {
		if (!@hasValue) {
			printf(C"INVALID!\n");
		}
		
		printf(C"custom_lval.address: Value = %s\n", @value.toCString());
		return &@value;
	}

	void assign(T value) {
		if (@hasValue) {
			printf(C"custom_lval.assign: Previous value = %s\n", @value.toCString());
		} else {
			printf(C"custom_lval.assign: Previous value = [NONE]\n");
		}
		printf(C"custom_lval.assign: New value = %s\n", value.toCString());
		@value = move value;
		@hasValue = true;
	}
	
	T& dissolve() {
		if (!@hasValue) {
			printf(C"INVALID!\n");
		}
		
		printf(C"custom_lval.dissolve: Value = %s\n", @value.toCString());
		return @value;
	}
	
	T move() {
		if (!@hasValue) {
			printf(C"INVALID!\n");
		}
		
		printf(C"custom_lval.move: Value = %s\n", @value.toCString());
		@hasValue = false;
		return move @value;
	}
}

class TestClass(int a, int b) {
	static Create(int a, int b) {
		return @(a, b);
	}
	
	const ubyte* toCString() {
		if (@a == 0) {
			if (@b == 0) {
				return C"Both Zero\n";
			}
		}
		
		if (@a < @b) {
			return C"OrderedLess\n";
		}
		
		if (@a > @b) {
			return C"OrderedMore\n";
		}
		
		return C"OrderedEqual\n";
	}
}

void addressAssignFunction(lval<TestClass> custom_lval<TestClass>& objectLval, TestClass value) {
	TestClass* valuePtr = &objectLval;
	
	printf(C"addressAssignFunction: Previous value = %s\n", (*valuePtr).toCString());
	
	*valuePtr = move value;
	
	printf(C"addressAssignFunction: New value = %s\n", (*valuePtr).toCString());
}

void assignFunction(lval<TestClass> custom_lval<TestClass>& objectLval, TestClass value) {
	printf(C"assignFunction: Previous value = %s\n", objectLval.toCString());
	
	objectLval = move value;
	
	printf(C"assignFunction: New value = %s\n", objectLval.toCString());
}

void moveFunction(lval<TestClass> custom_lval<TestClass>& objectLval) {
	printf(C"moveFunction: Previous value = %s\n", objectLval.toCString());
	
	TestClass value = move objectLval;
	
	printf(C"moveFunction: Moved value = %s\n", value.toCString());
	
	objectLval = TestClass(0, 0);
	
	printf(C"moveFunction: New value = %s\n", objectLval.toCString());
}

export int main(unused int argc, unused ubyte ** argv) {
	lval<TestClass> custom_lval<TestClass> value = lval<TestClass>(custom_lval<TestClass>(TestClass(2, 2)));
	
	printf(C"main: Value = %s\n", value.toCString());
	
	addressAssignFunction(value, TestClass(1, 2));
	
	printf(C"main: Value = %s\n", value.toCString());
	
	assignFunction(value, TestClass(2, 1));
	
	printf(C"main: Value = %s\n", value.toCString());
	
	moveFunction(value);
	
	printf(C"main: Value = %s\n", value.toCString());
	
	return 0;
}

