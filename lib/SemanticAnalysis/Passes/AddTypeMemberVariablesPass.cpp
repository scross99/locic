#include <locic/AST.hpp>
#include <locic/AST/Type.hpp>
#include <locic/SemanticAnalysis/Context.hpp>
#include <locic/SemanticAnalysis/ConvertVar.hpp>
#include <locic/SemanticAnalysis/Exception.hpp>
#include <locic/SemanticAnalysis/ScopeStack.hpp>
#include <locic/SemanticAnalysis/TypeResolver.hpp>

namespace locic {
	
	namespace SemanticAnalysis {
		
		class ExceptionCircularInheritanceDiag: public Error {
		public:
			ExceptionCircularInheritanceDiag(std::string typeName)
			: typeName_(std::move(typeName)) { }
			
			std::string toString() const {
				return makeString("exception type '%s' inherits itself via a circular dependency",
				                  typeName_.c_str());
			}
			
		private:
			std::string typeName_;
			
		};
		
		bool hasInheritanceCycle(const AST::TypeInstance& typeInstance) {
			auto parentType = typeInstance.parentType();
			while (parentType != nullptr && parentType->isException()) {
				if (parentType->getObjectType() == &typeInstance) {
					return true;
				}
				
				parentType = parentType->getObjectType()->parentType();
			}
			
			return false;
		}
		
		void checkForInheritanceCycle(Context& context, const AST::TypeInstance& rootTypeInstance) {
			auto typeInstance = &rootTypeInstance;
			while (true) {
				if (hasInheritanceCycle(*typeInstance)) {
					context.issueDiag(ExceptionCircularInheritanceDiag(typeInstance->fullName().toString()),
					                  typeInstance->debugInfo()->location);
				}
					
				const auto parentType = typeInstance->parentType();
				if (parentType == nullptr || !parentType->isException()) {
					break;
				}
				
				typeInstance = parentType->getObjectType();
				if (typeInstance == &rootTypeInstance) {
					break;
				}
			}
		}
		
		class ExceptionCannotInheritNonExceptionTypeDiag: public Error {
		public:
			ExceptionCannotInheritNonExceptionTypeDiag(const AST::TypeInstance& exceptionType,
			                                           const AST::Type* inheritType)
			: exceptionType_(exceptionType), inheritType_(inheritType) { }
			
			std::string toString() const {
				return makeString("'%s' cannot inherit from non-exception type '%s'",
				                  exceptionType_.fullName().toString(/*addPrefix=*/false).c_str(),
				                  inheritType_->toString().c_str());
			}
			
		private:
			const AST::TypeInstance& exceptionType_;
			const AST::Type* inheritType_;
			
		};
		
		class PatternMemberVarsNotSupportedDiag: public Error {
		public:
			PatternMemberVarsNotSupportedDiag() { }
			
			std::string toString() const {
				return "pattern variables not supported for member variables";
			}
			
		};
		
		// Fill in type instance structures with member variable information.
		void AddTypeInstanceMemberVariables(Context& context, const AST::Node<AST::TypeInstance>& typeInstanceNode,
				std::vector<AST::TypeInstance*>& typeInstancesToGenerateNoTagSets) {
			assert(typeInstanceNode->variables().empty());
			assert(typeInstanceNode->constructTypes().empty());
			
			if (typeInstanceNode->isException()) {
				// Add exception type parent using initializer.
				const auto& astInitializerNode = typeInstanceNode->initializer;
				if (astInitializerNode->kind == AST::ExceptionInitializer::INITIALIZE) {
					const auto semType = TypeResolver(context).resolveObjectType(astInitializerNode->symbol);
					
					if (!semType->isException()) {
						context.issueDiag(ExceptionCannotInheritNonExceptionTypeDiag(*typeInstanceNode, semType),
						                  astInitializerNode->symbol.location());
					}
					
					typeInstanceNode->setParentType(semType);
					
					checkForInheritanceCycle(context, *typeInstanceNode);
					
					// Also add parent as first member variable.
					// FIXME: We shouldn't be creating an AST::Var here; the solution
					//        is to remove this variable and have code that accesses
					//        it generated by CodeGen.
					auto parentVar = AST::Var::NamedVar(AST::Node<AST::TypeDecl>(),
					                                    String());
					parentVar->setConstructType(semType);
					parentVar->setLvalType(semType);
					typeInstanceNode->attachVariable(*parentVar);
				}
			}
			
			for (auto& astVarNode: *(typeInstanceNode->variableDecls)) {
				if (!astVarNode->isNamed()) {
					context.issueDiag(PatternMemberVarsNotSupportedDiag(),
					                  astVarNode.location());
				}
				
				auto var = ConvertVar(context, Debug::VarInfo::VAR_MEMBER, astVarNode);
				typeInstanceNode->attachVariable(*var);
			}
			
			if (typeInstanceNode->noTagSetDecl.isNull() && !typeInstanceNode->isPrimitive()) {
				// No tag set was specified so generate one from member variables.
				typeInstancesToGenerateNoTagSets.push_back(typeInstanceNode.get());
			}
		}
		
		void AddNamespaceDataTypeMemberVariables(Context& context, const AST::Node<AST::NamespaceData>& astNamespaceDataNode,
				std::vector<AST::TypeInstance*>& typeInstancesToGenerateNoTagSets) {
			for (const auto& astChildNamespaceNode: astNamespaceDataNode->namespaces) {
				auto& semChildNamespace = astChildNamespaceNode->nameSpace();
				
				PushScopeElement pushScopeElement(context.scopeStack(), ScopeElement::Namespace(semChildNamespace));
				AddNamespaceDataTypeMemberVariables(context, astChildNamespaceNode->data(), typeInstancesToGenerateNoTagSets);
			}
			
			for (const auto& astModuleScopeNode: astNamespaceDataNode->moduleScopes) {
				AddNamespaceDataTypeMemberVariables(context, astModuleScopeNode->data(),
				                                    typeInstancesToGenerateNoTagSets);
			}
			
			for (const auto& typeInstanceNode: astNamespaceDataNode->typeInstances) {
				{
					PushScopeElement pushScopeElement(context.scopeStack(), ScopeElement::TypeInstance(*typeInstanceNode));
					AddTypeInstanceMemberVariables(context, typeInstanceNode, typeInstancesToGenerateNoTagSets);
				}
				
				if (typeInstanceNode->isUnionDatatype()) {
					for (const auto& variantNode: *(typeInstanceNode->variantDecls)) {
						PushScopeElement pushScopeElement(context.scopeStack(), ScopeElement::TypeInstance(*variantNode));
						AddTypeInstanceMemberVariables(context, variantNode, typeInstancesToGenerateNoTagSets);
					}
				}
			}
		}
		
		const AST::TemplateVarArray& GetTypeInstanceNoTagSet(AST::TypeInstance& typeInstance) {
			if (!typeInstance.noTagSet().empty()) {
				return typeInstance.noTagSet();
			}
			
			AST::TemplateVarArray noTagSet;
			
			for (const auto& memberVar: typeInstance.variables()) {
				// TODO: fix this to be less simplistic by looking for
				// any template variable references inside the type.
				if (memberVar->constructType()->isTemplateVar()) {
					// TODO: remove const_cast.
					noTagSet.push_back(const_cast<AST::TemplateVar*>(memberVar->constructType()->getTemplateVar()));
				}
			}
			
			for (const auto& variant: typeInstance.variants()) {
				const auto& variantNoTagSet = GetTypeInstanceNoTagSet(*variant);
				for (const auto& childTagSetVar: variantNoTagSet) {
					noTagSet.push_back(childTagSetVar);
				}
			}
			
			typeInstance.setNoTagSet(std::move(noTagSet));
			
			return typeInstance.noTagSet();
		}
		
		void AddTypeMemberVariablesPass(Context& context, const AST::NamespaceList& rootASTNamespaces) {
			std::vector<AST::TypeInstance*> typeInstancesToGenerateNoTagSets;
			for (const auto& astNamespaceNode: rootASTNamespaces) {
				AddNamespaceDataTypeMemberVariables(context, astNamespaceNode->data(), typeInstancesToGenerateNoTagSets);
			}
			
			for (const auto& typeInstance: typeInstancesToGenerateNoTagSets) {
				(void) GetTypeInstanceNoTagSet(*typeInstance);
			}
		}
		
	}
	
}
