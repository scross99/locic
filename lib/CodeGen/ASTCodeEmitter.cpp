#include <locic/CodeGen/ASTCodeEmitter.hpp>

#include <locic/AST/Function.hpp>
#include <locic/AST/Type.hpp>

#include <locic/CodeGen/ArgInfo.hpp>
#include <locic/CodeGen/DefaultMethodEmitter.hpp>
#include <locic/CodeGen/Function.hpp>
#include <locic/CodeGen/InternalContext.hpp>
#include <locic/CodeGen/IREmitter.hpp>
#include <locic/CodeGen/Module.hpp>
#include <locic/CodeGen/PrimitiveFunctionEmitter.hpp>
#include <locic/CodeGen/ScopeEmitter.hpp>
#include <locic/CodeGen/ScopeExitActions.hpp>
#include <locic/CodeGen/Support.hpp>
#include <locic/CodeGen/TypeInfo.hpp>

#include <locic/AST/TypeInstance.hpp>

#include <locic/Support/MethodID.hpp>

namespace locic {
	
	namespace CodeGen {
		
		ASTCodeEmitter::ASTCodeEmitter(Function& functionGenerator)
		: functionGenerator_(functionGenerator) { }
		
		void
		ASTCodeEmitter::emitFunctionCode(const AST::TypeInstance* const typeInstance,
		                                 const AST::Function& function,
		                                 const bool isInnerMethod) {
			// TODO: remove this horrible code...
			const bool isOuterMethod = (function.fullName().last() == "__move" ||
			                            function.fullName().last() == "__destroy") &&
			                           !isInnerMethod;
			if (function.isAutoGenerated() || function.isPrimitive() || isOuterMethod) {
				emitBuiltInFunctionCode(typeInstance,
				                        function,
				                        isInnerMethod);
			} else {
				emitUserFunctionCode(function);
			}
		}
		
		llvm::Value*
		ASTCodeEmitter::emitBuiltInFunctionContents(const MethodID methodID,
		                                            const bool isInnerMethod,
		                                            const AST::TypeInstance* const typeInstance,
		                                            const AST::Function& function,
		                                            PendingResultArray args,
		                                            llvm::Value* const hintResultValue) {
			if (!function.isPrimitive()) {
				DefaultMethodEmitter defaultMethodEmitter(functionGenerator_);
				return defaultMethodEmitter.emitMethod(methodID,
				                                       isInnerMethod,
				                                       typeInstance->selfType(),
				                                       function.type(),
				                                       std::move(args),
				                                       hintResultValue);
			} else {
				assert(!isInnerMethod);
				
				AST::ValueArray templateArgs;
				for (const auto& templateVar: function.templateVariables()) {
					templateArgs.push_back(templateVar->selfRefValue());
				}
				
				const auto type = typeInstance != nullptr ? typeInstance->selfType() : nullptr;
				
				IREmitter irEmitter(functionGenerator_);
				PrimitiveFunctionEmitter primitiveFunctionEmitter(irEmitter);
				return primitiveFunctionEmitter.emitFunction(methodID, type,
				                                             arrayRef(templateArgs),
				                                             std::move(args),
				                                             hintResultValue);
			}
		}
		
		void
		ASTCodeEmitter::emitBuiltInFunctionCode(const AST::TypeInstance* const typeInstance,
		                                        const AST::Function& function,
		                                        const bool isInnerMethod) {
			auto& module = functionGenerator_.module();
			
			const auto& argInfo = functionGenerator_.getArgInfo();
			
			PendingResultArray args;
			
			Array<RefPendingResult, 1> contextPendingResult;
			if (argInfo.hasContextArgument()) {
				assert(typeInstance != nullptr);
				const auto contextValue = functionGenerator_.getContextValue();
				contextPendingResult.push_back(RefPendingResult(contextValue,
				                                                typeInstance->selfType()));
				args.push_back(contextPendingResult.back());
			}
			
			// Need an array to store all the pending results
			// being referred to in 'genTrivialPrimitiveFunctionCall'.
			Array<ValuePendingResult, 10> pendingResultArgs;
			
			const auto& argTypes = function.type().parameterTypes();
			for (size_t i = 0; i < argTypes.size(); i++) {
				const auto argValue = functionGenerator_.getArg(i);
				pendingResultArgs.push_back(ValuePendingResult(argValue, argTypes[i]));
				args.push_back(pendingResultArgs.back());
			}
			
			const auto& methodName = function.fullName().last();
			const auto methodID = module.context().getMethodID(CanonicalizeMethodName(methodName));
			
			const auto result = emitBuiltInFunctionContents(methodID,
			                                                isInnerMethod,
			                                                typeInstance,
			                                                function,
			                                                std::move(args),
			                                                functionGenerator_.getReturnVarOrNull());
			
			const auto returnType = function.type().returnType();
			
			IREmitter irEmitter(functionGenerator_);
			
			// Return the result in the appropriate way.
			if (argInfo.hasReturnVarArgument()) {
				irEmitter.emitStore(result,
				                    functionGenerator_.getReturnVar(),
				                    returnType);
				irEmitter.emitReturnVoid();
			} else if (!returnType->isBuiltInVoid()) {
				functionGenerator_.returnValue(result);
			} else {
				irEmitter.emitReturnVoid();
			}
		}
		
		void
		ASTCodeEmitter::emitUserFunctionCode(const AST::Function& function) {
			assert(!function.isAutoGenerated());
			
			ScopeLifetime functionScopeLifetime(functionGenerator_);
			
			emitParameterAssignments(function);
			emitScopeFunctionCode(function);
		}
		
		void
		ASTCodeEmitter::emitParameterAssignments(const AST::Function& function) {
			auto& module = functionGenerator_.module();
			IREmitter irEmitter(functionGenerator_);
			TypeInfo typeInfo(module);
			
			for (size_t i = 0; i < function.parameters().size(); i++) {
				const auto& paramVar = *(function.parameters()[i]);
				const auto paramType = paramVar.type();
				const auto paramIR = functionGenerator_.getArg(i);
				
				// We need to get a stack pointer to use as the variable's
				// address. If the argument was passed by value then
				// emitBind() will create an alloca for it, otherwise we
				// can use the pointer given to us by the caller.
				const auto varPtr = irEmitter.emitBind(paramIR, paramType);
				
				// Caller has transferred ownership to us, so call any
				// destructors when unwinding the function.
				irEmitter.scheduleDestructorCall(varPtr, paramType);
				
				functionGenerator_.setVarAddress(paramVar, varPtr);
			}
		}
		
		void
		ASTCodeEmitter::emitScopeFunctionCode(const AST::Function& function) {
			IREmitter irEmitter(functionGenerator_);
			ScopeEmitter(irEmitter).emitScope(*(function.scope()));
		}
		
	}
	
}
