#include <string>
#include <vector>

#include <locic/Support/Name.hpp>

#include <locic/AST/FunctionDecl.hpp>
#include <locic/AST/Node.hpp>
#include <locic/AST/RequireSpecifier.hpp>
#include <locic/AST/Scope.hpp>
#include <locic/AST/TypeDecl.hpp>
#include <locic/AST/Var.hpp>

#include <locic/SEM/Scope.hpp>

namespace locic {

	namespace AST {
		
		FunctionDecl::FunctionDecl() :
		isAutoGenerated_(false), isMethod_(false),
		isStatic_(false), isImported_(false), isExported_(false),
		isPrimitive_(false), isVarArg_(false),
		templateVariableDecls_(makeDefaultNode<TemplateVarList>()),
		constPredicate_(SEM::Predicate::False()),
		requiresPredicate_(SEM::Predicate::True()),
		moduleScope_(ModuleScope::Internal()) { }
		
		FunctionDecl::~FunctionDecl() { }
		
		SEM::GlobalStructure& FunctionDecl::parent() {
			return *parent_;
		}
		
		const SEM::GlobalStructure& FunctionDecl::parent() const {
			return *parent_;
		}
		
		void FunctionDecl::setParent(SEM::GlobalStructure argParent) {
			parent_ = make_optional(std::move(argParent));
		}
		
		SEM::Namespace& FunctionDecl::nameSpace() {
			return parent().nextNamespace();
		}
		
		const SEM::Namespace& FunctionDecl::nameSpace() const {
			return parent().nextNamespace();
		}
		
		const ModuleScope& FunctionDecl::moduleScope() const {
			return moduleScope_;
		}
		
		void FunctionDecl::setModuleScope(ModuleScope argModuleScope) {
			moduleScope_ = std::move(argModuleScope);
		}
		
		bool FunctionDecl::isAutoGenerated() const {
			return isAutoGenerated_;
		}
		
		void FunctionDecl::setAutoGenerated(const bool value) {
			 assert(!(value && hasScopeDecl()) &&
			        "Functions can't be marked auto-generated and "
				"have user-specified code.");
			isAutoGenerated_ = value;
		}
		
		bool FunctionDecl::isStatic() const {
			return isStatic_;
		}
		
		void FunctionDecl::setIsStatic(const bool value) {
			isStatic_ = value;
		}
		
		bool FunctionDecl::isVarArg() const {
			return isVarArg_;
		}
		
		void FunctionDecl::setIsVarArg(const bool value) {
			isVarArg_ = value;
		}
		
		bool FunctionDecl::isImported() const {
			return isImported_;
		}
		
		void FunctionDecl::setIsImported(const bool value) {
			isImported_ = value;
		}
		
		bool FunctionDecl::isExported() const {
			return isExported_;
		}
		
		void FunctionDecl::setIsExported(const bool value) {
			isExported_ = value;
		}
		
		bool FunctionDecl::isPrimitive() const {
			return isPrimitive_;
		}
		
		void FunctionDecl::setIsPrimitive(const bool value) {
			isPrimitive_ = value;
		}
		
		bool FunctionDecl::isMethod() const {
			return isMethod_;
		}
		
		void FunctionDecl::setMethod(const bool value) {
			isMethod_ = value;
		}
		
		bool FunctionDecl::isStaticMethod() const {
			return isMethod() && isStatic();
		}
		
		const Node<Name>& FunctionDecl::nameDecl() const {
			return nameDecl_;
		}
		
		void FunctionDecl::setNameDecl(Node<Name> pNameDecl) {
			nameDecl_ = std::move(pNameDecl);
		}
		
		const Name& FunctionDecl::fullName() const {
			assert(!fullName_.empty());
			return fullName_;
		}
		
		void FunctionDecl::setFullName(Name pFullName) {
			fullName_ = std::move(pFullName);
		}
		
		String FunctionDecl::canonicalName() const {
			return CanonicalizeMethodName(fullName().last());
		}
		
		void FunctionDecl::setType(const SEM::FunctionType pType) {
			type_ = pType;
		}
		
		const SEM::FunctionType& FunctionDecl::type() const {
			return type_;
		}
		
		Node<TypeDecl>& FunctionDecl::returnType() {
			assert(!isAutoGenerated());
			return returnType_;
		}
		
		const Node<TypeDecl>& FunctionDecl::returnType() const {
			assert(!isAutoGenerated());
			return returnType_;
		}
		
		void FunctionDecl::setReturnType(Node<TypeDecl> pReturnType) {
			returnType_ = std::move(pReturnType);
		}
		
		const Node<VarList>& FunctionDecl::parameterDecls() const {
			assert(!isAutoGenerated());
			return parameterDecls_;
		}
		
		void FunctionDecl::setParameterDecls(Node<VarList> pParameterDecls) {
			parameterDecls_ = std::move(pParameterDecls);
		}
		
		const std::vector<Var*>& FunctionDecl::parameters() const {
			return parameters_;
		}
		
		void FunctionDecl::setParameters(std::vector<Var*> pParameters) {
			parameters_ = std::move(pParameters);
		}
		
		bool FunctionDecl::hasScopeDecl() const {
			return scopeDecl_.get() != nullptr;
		}
		
		const Node<Scope>& FunctionDecl::scopeDecl() const {
			assert(!isAutoGenerated() &&
			       "Functions can't be marked auto-generated and "
			       "have user-specified code.");
			return scopeDecl_;
		}
		
		void FunctionDecl::setScopeDecl(Node<Scope> pScope) {
			assert(!isAutoGenerated() &&
			       "Functions can't be marked auto-generated and "
			       "have user-specified code.");
			scopeDecl_ = std::move(pScope);
		}
		
		bool FunctionDecl::hasGeneratedScope() const {
			return scope_.get() != nullptr;
		}
		
		const SEM::Scope& FunctionDecl::scope() const {
			assert(!isAutoGenerated() &&
			       "Functions can't be marked auto-generated and "
			       "have user-specified code.");
			return *scope_;
		}
		
		void FunctionDecl::setScope(std::unique_ptr<SEM::Scope> newScope) {
			assert(!hasGeneratedScope());
			assert(newScope.get() != nullptr);
			assert(!isAutoGenerated() &&
			       "Functions can't be marked auto-generated and "
			       "have user-specified code.");
			scope_ = std::move(newScope);
		}
		
		const Node<ConstSpecifier>& FunctionDecl::constSpecifier() const {
			return constSpecifier_;
		}
		
		void FunctionDecl::setConstSpecifier(Node<ConstSpecifier> pConstSpecifier) {
			constSpecifier_ = std::move(pConstSpecifier);
		}
		
		const SEM::Predicate& FunctionDecl::constPredicate() const {
			return constPredicate_;
		}
		
		void FunctionDecl::setConstPredicate(SEM::Predicate predicate) {
			constPredicate_ = std::move(predicate);
		}
		
		const Node<RequireSpecifier>& FunctionDecl::noexceptSpecifier() const {
			return noexceptSpecifier_;
		}
		
		void FunctionDecl::setNoexceptSpecifier(Node<RequireSpecifier> pNoexceptSpecifier) {
			noexceptSpecifier_ = std::move(pNoexceptSpecifier);
		}
		
		const SEM::Predicate& FunctionDecl::noexceptPredicate() const {
			return type().attributes().noExceptPredicate();
		}
		
		const Node<RequireSpecifier>& FunctionDecl::requireSpecifier() const {
			return requireSpecifier_;
		}
		
		void FunctionDecl::setRequireSpecifier(Node<RequireSpecifier> pRequireSpecifier) {
			requireSpecifier_ = std::move(pRequireSpecifier);
		}
		
		const SEM::Predicate& FunctionDecl::requiresPredicate() const {
			return requiresPredicate_;
		}
		
		void FunctionDecl::setRequiresPredicate(SEM::Predicate predicate) {
			requiresPredicate_ = std::move(predicate);
		}
		
		const Node<TemplateVarList>& FunctionDecl::templateVariableDecls() const {
			return templateVariableDecls_;
		}
		
		void FunctionDecl::setTemplateVariableDecls(Node<TemplateVarList> pTemplateVariables) {
			templateVariableDecls_ = std::move(pTemplateVariables);
		}
		
		SEM::TemplateVarArray& FunctionDecl::templateVariables() {
			return templateVariables_;
		}
		
		const SEM::TemplateVarArray& FunctionDecl::templateVariables() const {
			return templateVariables_;
		}
		
		FastMap<String, SEM::TemplateVar*>& FunctionDecl::namedTemplateVariables() {
			return namedTemplateVariables_;
		}
		
		const FastMap<String, SEM::TemplateVar*>& FunctionDecl::namedTemplateVariables() const {
			return namedTemplateVariables_;
		}
		
		FastMap<String, Var*>& FunctionDecl::namedVariables() {
			return namedVariables_;
		}
		
		const FastMap<String, Var*>& FunctionDecl::namedVariables() const {
			return namedVariables_;
		}
		
		void FunctionDecl::setDebugInfo(Debug::FunctionInfo newDebugInfo) {
			debugInfo_ = make_optional(std::move(newDebugInfo));
		}
		
		const Optional<Debug::FunctionInfo>& FunctionDecl::debugInfo() const {
			return debugInfo_;
		}
		
		std::string FunctionDecl::toString() const {
			// TODO!
			return "FunctionDecl";
		}
		
	}
	
}

