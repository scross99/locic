#include <string>
#include <vector>

#include <locic/Support/Name.hpp>

#include <locic/AST/FunctionDecl.hpp>
#include <locic/AST/Node.hpp>
#include <locic/AST/RequireSpecifier.hpp>
#include <locic/AST/Scope.hpp>
#include <locic/AST/TypeDecl.hpp>
#include <locic/AST/Var.hpp>

#include <locic/SEM/Scope.hpp>

namespace locic {

	namespace AST {
		
		FunctionDecl::FunctionDecl() :
		isDefinition_(false), isAutoGenerated_(false), isMethod_(false),
		isStatic_(false), isImported_(false), isExported_(false),
		isPrimitive_(false), isVarArg_(false),
		templateVariableDecls_(makeDefaultNode<TemplateVarList>()),
		constPredicate_(SEM::Predicate::False()),
		requiresPredicate_(SEM::Predicate::True()),
		semFunction_(nullptr), moduleScope_(ModuleScope::Internal()) { }
		
		FunctionDecl::~FunctionDecl() { }
		
		SEM::GlobalStructure& FunctionDecl::parent() {
			return *parent_;
		}
		
		const SEM::GlobalStructure& FunctionDecl::parent() const {
			return *parent_;
		}
		
		void FunctionDecl::setParent(SEM::GlobalStructure argParent) {
			parent_ = make_optional(std::move(argParent));
		}
		
		SEM::Namespace& FunctionDecl::nameSpace() {
			return parent().nextNamespace();
		}
		
		const SEM::Namespace& FunctionDecl::nameSpace() const {
			return parent().nextNamespace();
		}
		
		const ModuleScope& FunctionDecl::moduleScope() const {
			return moduleScope_;
		}
		
		void FunctionDecl::setModuleScope(ModuleScope argModuleScope) {
			moduleScope_ = std::move(argModuleScope);
		}
		
		bool FunctionDecl::isDeclaration() const {
			return !isDefinition_;
		}
		
		bool FunctionDecl::isDefinition() const {
			return isDefinition_;
		}
		
		void FunctionDecl::setIsDefinition(const bool value) {
			isDefinition_ = value;
		}
		
		bool FunctionDecl::isAutoGenerated() const {
			return isAutoGenerated_;
		}
		
		void FunctionDecl::setAutoGenerated(const bool value) {
			assert(isDefinition());
			isAutoGenerated_ = value;
		}
		
		bool FunctionDecl::isStatic() const {
			return isStatic_;
		}
		
		void FunctionDecl::setIsStatic(const bool value) {
			isStatic_ = value;
		}
		
		bool FunctionDecl::isVarArg() const {
			return isVarArg_;
		}
		
		void FunctionDecl::setIsVarArg(const bool value) {
			isVarArg_ = value;
		}
		
		bool FunctionDecl::isImported() const {
			return isImported_;
		}
		
		void FunctionDecl::setIsImported(const bool value) {
			isImported_ = value;
		}
		
		bool FunctionDecl::isExported() const {
			return isExported_;
		}
		
		void FunctionDecl::setIsExported(const bool value) {
			isExported_ = value;
		}
		
		bool FunctionDecl::isPrimitive() const {
			return isPrimitive_;
		}
		
		void FunctionDecl::setIsPrimitive(const bool value) {
			isPrimitive_ = value;
		}
		
		bool FunctionDecl::isMethod() const {
			return isMethod_;
		}
		
		void FunctionDecl::setMethod(const bool value) {
			isMethod_ = value;
		}
		
		const Node<Name>& FunctionDecl::name() const {
			return name_;
		}
		
		void FunctionDecl::setName(Node<Name> pName) {
			name_ = std::move(pName);
		}
		
		void FunctionDecl::setType(const SEM::FunctionType pType) {
			type_ = pType;
		}
		
		const SEM::FunctionType& FunctionDecl::type() const {
			return type_;
		}
		
		Node<TypeDecl>& FunctionDecl::returnType() {
			assert(!isAutoGenerated());
			return returnType_;
		}
		
		const Node<TypeDecl>& FunctionDecl::returnType() const {
			assert(!isAutoGenerated());
			return returnType_;
		}
		
		void FunctionDecl::setReturnType(Node<TypeDecl> pReturnType) {
			returnType_ = std::move(pReturnType);
		}
		
		const Node<VarList>& FunctionDecl::parameters() const {
			assert(!isAutoGenerated());
			return parameters_;
		}
		
		void FunctionDecl::setParameters(Node<VarList> pParameters) {
			parameters_ = std::move(pParameters);
		}
		
		const Node<Scope>& FunctionDecl::scopeDecl() const {
			assert(isDefinition() && !isAutoGenerated());
			return scopeDecl_;
		}
		
		void FunctionDecl::setScopeDecl(Node<Scope> pScope) {
			assert(isDefinition());
			scopeDecl_ = std::move(pScope);
		}
		
		const SEM::Scope& FunctionDecl::scope() const {
			assert(isDefinition());
			return *scope_;
		}
		
		void FunctionDecl::setScope(std::unique_ptr<SEM::Scope> newScope) {
			assert(scope_.get() == nullptr);
			assert(newScope.get() != nullptr);
			assert(!isAutoGenerated() &&
			       "Functions can't be marked auto-generated and have definitions.");
			scope_ = std::move(newScope);
		}
		
		const Node<ConstSpecifier>& FunctionDecl::constSpecifier() const {
			return constSpecifier_;
		}
		
		void FunctionDecl::setConstSpecifier(Node<ConstSpecifier> pConstSpecifier) {
			constSpecifier_ = std::move(pConstSpecifier);
		}
		
		const SEM::Predicate& FunctionDecl::constPredicate() const {
			return constPredicate_;
		}
		
		void FunctionDecl::setConstPredicate(SEM::Predicate predicate) {
			constPredicate_ = std::move(predicate);
		}
		
		const Node<RequireSpecifier>& FunctionDecl::noexceptSpecifier() const {
			return noexceptSpecifier_;
		}
		
		void FunctionDecl::setNoexceptSpecifier(Node<RequireSpecifier> pNoexceptSpecifier) {
			noexceptSpecifier_ = std::move(pNoexceptSpecifier);
		}
		
		const SEM::Predicate& FunctionDecl::noexceptPredicate() const {
			return type().attributes().noExceptPredicate();
		}
		
		const Node<RequireSpecifier>& FunctionDecl::requireSpecifier() const {
			return requireSpecifier_;
		}
		
		void FunctionDecl::setRequireSpecifier(Node<RequireSpecifier> pRequireSpecifier) {
			requireSpecifier_ = std::move(pRequireSpecifier);
		}
		
		const SEM::Predicate& FunctionDecl::requiresPredicate() const {
			return requiresPredicate_;
		}
		
		void FunctionDecl::setRequiresPredicate(SEM::Predicate predicate) {
			requiresPredicate_ = std::move(predicate);
		}
		
		const Node<TemplateVarList>& FunctionDecl::templateVariableDecls() const {
			return templateVariableDecls_;
		}
		
		void FunctionDecl::setTemplateVariableDecls(Node<TemplateVarList> pTemplateVariables) {
			templateVariableDecls_ = std::move(pTemplateVariables);
		}
		
		SEM::TemplateVarArray& FunctionDecl::templateVariables() {
			return templateVariables_;
		}
		
		const SEM::TemplateVarArray& FunctionDecl::templateVariables() const {
			return templateVariables_;
		}
		
		FastMap<String, SEM::TemplateVar*>& FunctionDecl::namedTemplateVariables() {
			return namedTemplateVariables_;
		}
		
		const FastMap<String, SEM::TemplateVar*>& FunctionDecl::namedTemplateVariables() const {
			return namedTemplateVariables_;
		}
		
		void FunctionDecl::setSEMFunction(SEM::Function& function) {
			assert(semFunction_ == nullptr);
			semFunction_ = &function;
		}
		
		SEM::Function& FunctionDecl::semFunction() {
			assert(semFunction_ != nullptr);
			return *semFunction_;
		}
		
		FastMap<String, Var*>& FunctionDecl::namedVariables() {
			return namedVariables_;
		}
		
		const FastMap<String, Var*>& FunctionDecl::namedVariables() const {
			return namedVariables_;
		}
		
		void FunctionDecl::setDebugInfo(Debug::FunctionInfo newDebugInfo) {
			debugInfo_ = make_optional(std::move(newDebugInfo));
		}
		
		const Optional<Debug::FunctionInfo>& FunctionDecl::debugInfo() const {
			return debugInfo_;
		}
		
		std::string FunctionDecl::toString() const {
			if (isDeclaration()) {
				return makeString("FunctionDecl(name = %s, returnType = %s, ... (TODO))",
					name()->toString().c_str(), returnType().toString().c_str());
			} else {
				if (isAutoGenerated()) {
					return makeString("DefaultFunctionDef(name = %s)",
						name()->toString().c_str());
				} else {
					return makeString("FunctionDef(name = %s, returnType = %s, ... (TODO))",
						name()->toString().c_str(), returnType().toString().c_str());
				}
			}
		}
		
	}
	
}

