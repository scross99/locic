export std.concurrency 0.1.0 {

	namespace std {
		
		namespace concurrency {
			
			template <typename T>
			require(sized_type<T>)
			// TODO: use a queue<T>!
			class message_queue(__override_const mutex mutex, size_t position, varray<T> array, event::generator generator) {
				static create() {
					return @(mutex(), 0u, varray<T>(), event::generator());
				}
				
				bool empty() const {
					unused auto lock = unique_lock(@mutex);
					assert @position <= @array.size();
					return @position == @array.size();
				}
				
				void send(T message) require(movable<T>) {
					unused auto lock = unique_lock(@mutex);
					assert @position <= @array.size();
					@array.push_back(move message);
					assert @position < @array.size();
					@generator.notify();
				}
				
				T receive() require(movable<T>) {
					unused auto lock = unique_lock(@mutex);
					
					assert @position < @array.size();
					// TODO: use a queue<T>!
					T message = move @array[@position];
					@position += 1u;
					
					if (@position == @array.size()) {
						@generator.reset();
					}
					
					return move message;
				}
				
				event::source event_source() const noexcept {
					return @generator.event_source();
				}
			}
			
		}
	}
	
}


