#ifndef LOCIC_AST_FUNCTIONDECL_HPP
#define LOCIC_AST_FUNCTIONDECL_HPP

#include <string>
#include <vector>

#include <locic/Support/Name.hpp>

#include <locic/AST/ConstSpecifier.hpp>
#include <locic/AST/ModuleScope.hpp>
#include <locic/AST/Node.hpp>
#include <locic/AST/RequireSpecifier.hpp>
#include <locic/AST/Scope.hpp>
#include <locic/AST/Symbol.hpp>
#include <locic/AST/TemplateVar.hpp>
#include <locic/AST/TypeDecl.hpp>
#include <locic/AST/Var.hpp>

#include <locic/Debug/FunctionInfo.hpp>

#include <locic/SEM/FunctionType.hpp>
#include <locic/SEM/GlobalStructure.hpp>

#include <locic/Support/FastMap.hpp>

namespace locic {
	
	namespace SEM {
		
		class Function;
		class Namespace;
		class Scope;
		
	}
	
	namespace AST {
		
		class FunctionDecl {
		public:
			FunctionDecl();
			~FunctionDecl();
			
			SEM::GlobalStructure& parent();
			const SEM::GlobalStructure& parent() const;
			void setParent(SEM::GlobalStructure parent);
			
			SEM::Namespace& nameSpace();
			const SEM::Namespace& nameSpace() const;
			
			const ModuleScope& moduleScope() const;
			void setModuleScope(ModuleScope moduleScope);
			
			bool isDeclaration() const;
			bool isDefinition() const;
			void setIsDefinition(bool value);
			
			/**
			 * \brief Get/set whether this function is auto-generated.
			 * 
			 * Default functions are generated for various types
			 * and provide a generic implementation (e.g. copy an
			 * object by copying each member value) that doesn't
			 * have to be specified manually.
			 */
			bool isAutoGenerated() const;
			void setAutoGenerated(bool value);
			
			/**
			 * \brief Get/set whether this function is a static method.
			 */
			bool isStatic() const;
			void setIsStatic(bool value);
			
			/**
			 * \brief Get/set whether this function is vararg.
			 */
			bool isVarArg() const;
			void setIsVarArg(bool value);
			
			/**
			 * \brief Get/set whether this function is marked 'import'.
			 */
			bool isImported() const;
			void setIsImported(bool value);
			
			/**
			 * \brief Get/set whether this function is marked 'export'.
			 */
			bool isExported() const;
			void setIsExported(bool value);
			
			/**
			 * \brief Get/set whether this function is primitive.
			 * 
			 * A primitive function is an 'axiom' of the language,
			 * such as the methods of type 'int'.
			 */
			bool isPrimitive() const;
			void setIsPrimitive(bool value);
			
			/**
			 * \brief Get/set whether this function is a method.
			 * 
			 * NOTE: This returns true for static methods.
			 */
			void setMethod(bool pIsMethod);
			bool isMethod() const;
			
			const Node<Name>& name() const;
			void setName(Node<Name> name);
			
			String canonicalName() const;
			
			void setType(SEM::FunctionType type);
			const SEM::FunctionType& type() const;
			
			Node<TypeDecl>& returnType();
			const Node<TypeDecl>& returnType() const;
			void setReturnType(Node<TypeDecl> returnType);
			
			const Node<VarList>& parameters() const;
			void setParameters(Node<VarList> parameters);
			
			const Node<Scope>& scopeDecl() const;
			void setScopeDecl(Node<Scope> scopeDecl);
			
			const SEM::Scope& scope() const;
			void setScope(std::unique_ptr<SEM::Scope> scope);
			
			const Node<ConstSpecifier>& constSpecifier() const;
			void setConstSpecifier(Node<ConstSpecifier> constSpecifier);
			
			const SEM::Predicate& constPredicate() const;
			void setConstPredicate(SEM::Predicate predicate);
			
			const Node<RequireSpecifier>& noexceptSpecifier() const;
			void setNoexceptSpecifier(Node<RequireSpecifier> noexceptSpecifier);
			
			const SEM::Predicate& noexceptPredicate() const;
			
			const Node<RequireSpecifier>& requireSpecifier() const;
			void setRequireSpecifier(Node<RequireSpecifier> requireSpecifier);
			
			const SEM::Predicate& requiresPredicate() const;
			void setRequiresPredicate(SEM::Predicate predicate);
			
			const Node<TemplateVarList>& templateVariableDecls() const;
			void setTemplateVariableDecls(Node<TemplateVarList> templateVariables);
			
			SEM::TemplateVarArray& templateVariables();
			const SEM::TemplateVarArray& templateVariables() const;
			
			FastMap<String, SEM::TemplateVar*>& namedTemplateVariables();
			const FastMap<String, SEM::TemplateVar*>& namedTemplateVariables() const;
			
			void setSEMFunction(SEM::Function& function);
			SEM::Function& semFunction();
			
			FastMap<String, Var*>& namedVariables();
			const FastMap<String, Var*>& namedVariables() const;
			
			void setDebugInfo(Debug::FunctionInfo debugInfo);
			const Optional<Debug::FunctionInfo>& debugInfo() const;
			
			std::string toString() const;
			
		private:
			Optional<SEM::GlobalStructure> parent_;
			
			bool isDefinition_, isAutoGenerated_;
			bool isMethod_, isStatic_;
			bool isImported_, isExported_;
			bool isPrimitive_, isVarArg_;
			
			Node<Name> name_;
			
			Node<TemplateVarList> templateVariableDecls_;
			SEM::TemplateVarArray templateVariables_;
			FastMap<String, SEM::TemplateVar*> namedTemplateVariables_;
			
			SEM::FunctionType type_;
			Node<TypeDecl> returnType_;
			
			Node<VarList> parameters_;
			FastMap<String, Var*> namedVariables_;
			
			Node<Scope> scopeDecl_;
			std::unique_ptr<SEM::Scope> scope_;
			
			Node<ConstSpecifier> constSpecifier_;
			SEM::Predicate constPredicate_;
			
			Node<RequireSpecifier> noexceptSpecifier_;
			
			Node<RequireSpecifier> requireSpecifier_;
			SEM::Predicate requiresPredicate_;
			
			Optional<Debug::FunctionInfo> debugInfo_;
			SEM::Function* semFunction_;
			
			ModuleScope moduleScope_;
			
		};
		
		typedef std::vector<Node<FunctionDecl>> FunctionList;
		
	}
	
}

#endif
