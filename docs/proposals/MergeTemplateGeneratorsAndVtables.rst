Proposal: Merge Template Generators and Vtables
===============================================

.. Note::
	Feature awaiting further design consideration.

This is a proposal to significantly reduce the overhead of templates by merging template generators and vtables.

Current issues
--------------

Size of typename
~~~~~~~~~~~~~~~~

``typename_t`` is currently equivalent to:

.. code-block:: c++

	struct typename_t {
		void* vtable;
		void* template_generator;
		uint64_t path;
	};

Likely overhead:

* 32-bit machine: size = 16 bytes, overhead versus pointer = 4x
* 64-bit machine: size = 24 bytes, overhead versus pointer = 3x

The size of ``typename_t`` is important because the template generators produce an array of typename, which must be pre-allocated on the stack. The aim is to reduce this to just a single pointer.

Size of ref
~~~~~~~~~~~

References to interfaces are currently equivalent to:

.. code-block:: c++

	struct ref_t {
		void* this;
		void* vtable;
		void* template_generator;
		uint64_t path;
	};

Likely overhead:

* 32-bit machine: size = 20 bytes, overhead versus pointer pair = 2.5x
* 64-bit machine: size = 32 bytes, overhead versus pointer pair = 2x

This means that every ``Interface&`` type is large. The aim is to reduce this to just a pair of the ``this`` pointer and the ``vtable`` pointer.

Multiple indirect calls
~~~~~~~~~~~~~~~~~~~~~~~

Consider:

.. code-block:: c++

	template <typename T>
	class Example {
		void method();
	}
	
	void f(Example& object) {
		g(object);
	}
	
	void g(Interface& object) {
		object.method();
	}

This code involves two indirect calls:

* The ``object.method()`` call in ``g()`` will call ``Example::method()``.
* ``Example::method()`` calls its template generator (which from its perspective is just a function pointer) to get the template arguments.

Approach
--------

Accessing vtable via template generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Considering the interface reference:

.. code-block:: c++

	struct ref_t {
		void* this;
		void* vtable;
		void* template_generator;
		uint64_t path;
	};

We can make the following observations:

* The language allows any type, including primitives like ``int``, to be used polymorphically, so we can't get any type information into/out of the ``this`` pointer. We therefore need at least an extra pointer.
* The ``vtable`` is generated by the compiler at a point where the template arguments are **unknown**. For example, we know the vtable of ``std::varray<T>``, but type ``T`` may come from another module.
* There is a chain of template generators from the point where template arguments are known to where the vtable is known.

This means that the template generator could be used to call into the vtable, turning the interface reference type into:

.. code-block:: c++

	struct ref_t {
		void* this;
		void* vtable;
		uint64_t path;
	};

And ``typename_t`` would become:

.. code-block:: c++

	struct typename_t {
		void* vtable;
		uint64_t path;
	};

Calls through template generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dynamic dispatch must then call the template generator. This effectively means template generators no longer produce template arguments, but instead they call into a target function/method and give it the arguments directly.

A root template generator might now look like:

.. code-block:: c++

	// 64 bits in a path.
	const size_t PATH_BITS = 64;
	
	struct callinfo_t {
		uint64_t method_hash;
		typename_t types[8];
		void* root_template_generator;
		uint64_t path;
		size_t path_position;
	};
	
	<return arg> ROOT_0(hidden callinfo_t* callinfo, ...<call args>...) {
		callinfo->root_template_generator = ROOT_0;
		callinfo->types[0] = { VTABLE_int, 0 };
		callinfo->path_position = PATH_BITS - 1 - ctlz(callinfo->path)
		return tailcall TPLGEN_g(callinfo, ...<call args>...);
	}

We would generate a vtable corresponding to the template generator like so:

.. code-block:: c++

	const vtable_t ROOT_0_vtable = { ROOT_0, ROOT_0, ... };

An intermediate template generator might look like:

.. code-block:: c++

	<return arg> TPLGEN_g(hidden callinfo_t* callinfo, ...<call args>...) {
		if (callinfo->position == 0) {
			// End of path => call g(); g() uses callinfo to get its
			// template arguments.
			return tailcall g(callinfo, ...<call args>...);
		}
		
		callinfo->position--;
		const auto subPath = (callinfo->path >> callinfo->position);
		const auto mask = 0x3;
		const auto component = (subPath & mask);
		
		switch (component) {
		case 0:
			// Template parameters for 'i<T, byte>()':
			//   * 'T': first argument of parent, so just copy it across.
			//   * 'byte': add vtable and null template generator.
			callinfo->types[1] = { VTABLE_byte, 0 };
			
			// Still going => pass types to generator for 'i()'.
			return tailcall TPLGEN_i(callinfo, ...<call args>...);
		case 1:
			// Template parameters for 'j<T, byte>()':
			//   * 'T': first argument of parent, so just copy it across.
			//   * 'short': add vtable and null template generator.
			callinfo->types[1] = { VTABLE_short, 0 };
			
			// Still going => pass types to generator for 'j()'.
			return tailcall TPLGEN_j(callinfo, ...<call args>...);
		default:
			unreachable;
		}
	}

Dynamic dispatch calls might look like:

.. code-block:: c++

	int callMethod(ref_t reference, int arg0, int arg1) {
		typedef int (*method_type)(hidden callinfo_t*, int, int);
		method_type ptr = reference.vtable[METHOD_HASH_INDEX];
		
		callinfo_t callinfo;
		
		// Must set this to disambiguate which method should be called.
		callinfo.method_hash = METHOD_HASH;
		
		// Must set this to disambiguate which route to take down the template generator graph.
		callinfo.path = reference.path;
		
		return ptr(&callinfo, arg0, arg1);
	}

By calling through the template generator we also eliminate the extra indirect call when the function/method tries to access its own template arguments.

Encoding path into vtable pointer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The solution described above reduces an interface reference down to:

.. code-block:: c++

	struct ref_t {
		void* this;
		void* vtable;
		uint64_t path;
	};

We would like to remove the ``path`` element; this can only be achieved by encoding the path into the vtable pointer.

For a start, there are some available bits due to the alignment of vtables. If a vtable contained 16 pointers then we would have:

* 32-bit machine: vtable size = 64 bytes, (set align=size), available bits = 6 bits
* 64-bit machine: vtable size = 128 bytes, (set align=size), available bits = 7 bits

Dynamic dispatch calls would then have to clear the bits when calling a method:

.. code-block:: c++

	int callMethod(ref_t reference, int arg0, int arg1) {
		typedef int (*method_type)(hidden callinfo_t*, int, int);
		
		void** fixed_vtable = reference.vtable & ~(127);
		method_type ptr = fixed_vtable[METHOD_HASH_INDEX];
		
		callinfo_t callinfo;
		
		// Must set this to disambiguate which method should be called.
		callinfo.method_hash = METHOD_HASH;
		
		// Must set this to disambiguate which route to take down the template generator graph.
		callinfo.path = reference.vtable & 127;
		
		return ptr(&callinfo, arg0, arg1);
	}

However this relies on the path fitting into the available bits.

Reduce callinfo size
~~~~~~~~~~~~~~~~~~~~

After encoding the path into the vtable pointer, we can reduce ``callinfo_t`` to:

.. code-block:: c++

	struct callinfo_t {
		uint64_t method_hash;
		typename_t types[8];
		void* vtable;
		size_t path_position;
	};

In this case the root template generator no longer needs to set ``callinfo->root_template_generator`` and the dynamic dispatch code sets ``callinfo->vtable``.

Furthermore, ``typename_t`` is now just a vtable pointer, so that has already significantly reduced the size of ``callinfo_t``.

Encoding larger paths into vtable pointer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A simple solution to encode larger paths into the vtable pointer is to produce a larger vtable for the root template generator. For example, a vtable could be repeated a power of two number of times in memory to get extra available bits:

* 2 contiguous copies of vtable: extra 1 bit
* 4 contiguous copies of vtable: extra 2 bits
* 8 contiguous copies of vtable: extra 3 bits
* etc.

Increasing the size of the allocated space for the vtable effectively means allocating more bits in the address. Regardless of the machine you have:

* 8 available bits: requires 256 bytes of vtable data
* 9 available bits: requires 512 bytes of vtable data
* 10 available bits: requires 1024 bytes of vtable data
* etc.

Clearly, the memory required is exponential in terms of the number of path bits required. So it's important to keep the path size as small as possible. Another issue is that the root template generator must know that it needs to allocated more vtable data, so that we can minimise space overhead in most cases.

Reducing path size using modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Path bits are currently allocated for every templated function/method calls **within** a module, but this is unnecessary. We can perform template substitution within modules, so we only need to allocate path bits for calls from one module to another.

.. code-block:: c++

	// ---- Module 1.
	void a() {
		b<int>();
	}
	
	// ---- Module 2.
	template <typename T>
	void b() {
		c<T, float>();
	}
	
	template <typename S, typename T>
	void c() {
		d<T, S>();
	}
	
	// ---- Module 3.
	template <typename S, typename T>
	void h();

We can partially substitute ``c()`` to produce:

.. code-block:: c++

	// ---- Module 1.
	void a() {
		b<int>();
	}
	
	// ---- Module 2.
	template <typename T>
	void b() {
		c_SUBSTITUTED<T>();
	}
	
	template <typename T>
	void c_SUBSTITUTED() {
		d<float, T>();
	}
	
	// ---- Module 3.
	template <typename S, typename T>
	void d();

Effectively the substitutions pass the template arguments as received to our module directly around our module's code unmodified. For example:

.. code-block:: c++

	// All c
	template <typename T>
	export void f(T value) {
		g<wrapper<T>>(wrapper<T>(value));
	}
	
	template <typename T>
	void g(T value) {
		h<T>(value);
	}
	
	template <typename T>
	import void h(T value);

This becomes:

.. code-block:: c++

	template <typename T>
	void f(T value) {
		g_SUBSTITUTED<T>(wrapper<T>(value));
	}
	
	template <typename T>
	void g_SUBSTITUTED(wrapper<T> value) {
		h<wrapper<T>>(value);
	}
	
	template <typename T>
	import void h(T value);

These substitutions mean that all code in our module can use the same path value (for a given template generator graph).

Determining path size at compile-time
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This proposal suggests adding a ``depth`` attribute to imported templates, which indicates how many bits they require in their path:

.. code-block:: c++

	template(depth 2) <typename T>
	import void f(T value);

Not specifying the ``depth`` means that it is zero, and hence either:

* The module does not pass the template variables it is given to any other modules.
* The module passes template variables in the same form to other modules as it is given them, and those modules have ``depth=0``.

(The second case is the result of the pass-through optimisation.)

This has the following advantages:

* A known depth means root template generators know how many bits must be available and hence can allocate vtable sizes accordingly.
* The compiler can warn when the ``depth`` becomes large enough that the template generator vtable is huge (at 12+ bits it starts taking 4+KiB).
* We can prevent template cycles between modules, because they would end up with infinite depth.
* We can remove ``path_position`` from ``callinfo_t``, because each intermediate template generator knows exactly its offset within the path.

Summary
-------

This section describes the result of implementing all the ideas in the proposal.

callinfo_t
~~~~~~~~~~

.. code-block:: c++

	struct callinfo_t {
		uint64_t method_hash;
		void* vtable;
		typename_t types[8];
	};

Interface reference
~~~~~~~~~~~~~~~~~~~

.. code-block:: c++

	struct ref_t {
		void* this;
		void* vtable;
	};
	
	<return arg> call(ref_t ref, ...<call args>...) {
		typedef <return arg> (*method_type)(hidden callinfo_t*, ...);
		
		void** fixed_vtable = ref.vtable & ~(127);
		method_type ptr = fixed_vtable[METHOD_HASH % VTABLE_SIZE];
		
		callinfo_t callinfo;
		callinfo.method_hash = METHOD_HASH;
		callinfo.vtable = ref.vtable;
		return ptr(&callinfo, ref.this, ...<call args>...);
	}

typename_t
~~~~~~~~~~

.. code-block:: c++

	struct typename_t {
		void* vtable;
	};
	
	<return arg> call(typename_t ref, ...<call args>...) {
		typedef <return arg> (*static_method_type)(hidden callinfo_t*, ...);
		
		void** fixed_vtable = ref.vtable & ~(127);
		static_method_type ptr = fixed_vtable[METHOD_HASH % VTABLE_SIZE];
		
		callinfo_t callinfo;
		callinfo.method_hash = METHOD_HASH;
		callinfo.vtable = ref.vtable;
		return ptr(&callinfo, ...<call args>...);
	}

Root template generator
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++
	
	<return arg> ROOT_0(hidden callinfo_t* callinfo, ...<call args>...) {
		callinfo->types[0] = { VTABLE_int };
		return tailcall INTERMEDIATE_0(callinfo, ...<call args>...);
	}

Root template generator vtable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A root template generator allocates space for one or more vtables, each of which are identical. The root template generator vtable will have an entry for each offset:

.. code-block:: c++

	const vtable_t ROOT_vtable = { ROOT_0, ROOT_1, ROOT_2, ROOT_3, ROOT_4, ... };

Intermediate template generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++

	<return arg> INTERMEDIATE_0(hidden callinfo_t* callinfo, ...<call args>...) {
		const auto subPath = (callinfo->vtable >> NEXT_MODULE_TEMPLATE_DEPTH);
		const auto component = (subPath & 0x3);
		
		switch (component) {
		case 0:
			// Path terminated; call our own function.
			return tailcall our_exported_function(callinfo, ...<call args>...);
		case 1:
			// Pass the types to next intermediate generator.
			callinfo->types[1] = { VTABLE_byte };
			return tailcall NEXT_INTERMEDIATE_0(callinfo, ...<call args>...);
		case 2:
			// Pass the types to next intermediate generator.
			callinfo->types[1] = { VTABLE_short };
			return tailcall NEXT_INTERMEDIATE_0(callinfo, ...<call args>...);
		default:
			unreachable;
		}
	}

Intermediate template generator vtable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Intermediate template generators don't have a vtable, but they do have functions for each of the vtable offsets:

.. code-block:: c++

	<return arg> INTERMEDIATE_0(hidden callinfo_t* callinfo, ...<call args>...);
	<return arg> INTERMEDIATE_1(hidden callinfo_t* callinfo, ...<call args>...);
	<return arg> INTERMEDIATE_2(hidden callinfo_t* callinfo, ...<call args>...);
	// etc.

Receiving template arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++

	<return arg> exported_templated_function(hidden callinfo_t* callinfo, ...<call args>...) {
		typename_t first_arg = callinfo->types[0];
		typename_t second_arg = callinfo->types[1];
		
		return internal_templated_function(callinfo, ...<call args>...);
	}

Sending template arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++

	<return arg> function(hidden callinfo_t* callinfo, ...<call args>...) {
		callinfo->vtable |= (TEMPLATE_PATH_VALUE << NEXT_MODULE_TEMPLATE_DEPTH);
		return imported_templated_function(callinfo, ...<call args>...);
	}

Conflict resolution stub
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c++

	<return arg> conflict_resolution_stub(hidden callinfo_t* callinfo, ...<call args>...) {
		switch (callinfo->method_hash) {
			case HASH_METHOD_0:
				return tailcall method0(callinfo, ...<call args>...);
			case HASH_METHOD_1:
				return tailcall method1(callinfo, ...<call args>...);
			default:
				unreachable;
		}
	}
